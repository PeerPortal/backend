

### ** 后端技术文档（详细版）**

**版本:** 2.0
**目标:** 本文档旨在为“启航引路人”项目的后端开发提供一份全面的技术规范和实施蓝图。它涵盖了从环境配置、项目结构到具体API实现和部署的每一个环节。

### 1\. 技术栈与选型理由

| 类别 | 技术 | 选型理由 |
| :--- | :--- | :--- |
| **核心框架** | **FastAPI** | 基于其极高的性能（与Node.js和Go相当）、自动生成的交互式API文档(Swagger UI)、强大的依赖注入系统以及对异步编程的原生支持。 |
| **数据验证** | **Pydantic V2** | 提供无与伦比的运行时类型检查和数据验证能力，保证了API输入和输出的数据完整性。其`BaseModel`是定义数据模式（Schema）的基石。 |
| **数据库** | **Supabase (PostgreSQL)** | Supabase提供了一个全功能的PostgreSQL数据库，并集成了认证、存储和实时API。我们主要利用其核心的PostgreSQL能力和JWT认证机制。 |
| **数据库交互** | **`asyncpg` + SQLAlchemy Core** | `asyncpg`是目前性能最高的Python异步PostgreSQL驱动。我们结合使用SQLAlchemy Core的表达式语言来安全、编程化地构建SQL查询，避免了拼接原始SQL字符串的风险，同时比完整的ORM更轻量、更灵活。 |
| **认证鉴权** | **JWT + `python-jose`** | 遵循行业标准，使用Supabase签发的JWT进行无状态认证。`python-jose`库用于在后端安全地解码和验证这些Token。 |

### 2\. 项目结构

为保证代码的可维护性和扩展性，我们采用严格的模块化分层结构。

```
/app
├── api/
│   ├── deps.py             # 可复用的依赖项 (如用户认证、数据库会话)
│   └── routers/
│       ├── profile_router.py # 用户资料API
│       ├── service_router.py # 服务API
│       └── order_router.py   # 订单API
│
├── core/
│   ├── config.py             # 应用配置 (通过Pydantic Settings管理环境变量)
│   └── db.py                 # 数据库连接池与生命周期管理
│
├── crud/
│   ├── crud_base.py          # (可选) 通用的CRUD基类
│   ├── crud_profile.py       # 用户资料的数据库操作函数
│   └── crud_service.py       # 服务的数据库操作函数
│
├── schemas/
│   ├── profile_schema.py     # 用户资料的Pydantic模型/模式
│   ├── service_schema.py     # 服务的Pydantic模型/模式
│   └── token_schema.py       # JWT Token负载的模型
│
└── main.py                 # FastAPI应用主入口及中间件配置
```

### 3\. 数据库交互层 (`app/core/db.py`)

我们使用FastAPI的`lifespan`事件来管理数据库连接池的生命周期，确保应用启动时连接，关闭时安全释放。

```python
# app/core/db.py
import asyncpg
from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.core.config import settings

# 定义一个全局变量来持有连接池
db_pool: asyncpg.Pool = None

@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    应用生命周期管理器，在应用启动时初始化资源，在关闭时清理。
    """
    global db_pool
    print("Connecting to database...")
    try:
        # 从配置中读取数据库URL，创建连接池
        db_pool = await asyncpg.create_pool(
            dsn=settings.DATABASE_URL,
            min_size=settings.DB_POOL_MIN_SIZE,
            max_size=settings.DB_POOL_MAX_SIZE
        )
        print("Database connection pool created successfully.")
    except Exception as e:
        print(f"Failed to create database connection pool: {e}")
        raise

    yield  # 应用在此处运行

    if db_pool:
        print("Closing database connection pool...")
        await db_pool.close()
        print("Database connection pool closed.")

# 一个可用于依赖注入的函数，用于获取数据库连接
async def get_db_connection() -> asyncpg.Connection:
    # 卫语句：确保连接池已初始化
    if not db_pool:
        raise RuntimeError("Database connection pool is not initialized.")
    
    async with db_pool.acquire() as connection:
        yield connection
```

### 4\. 认证与授权层 (`app/api/deps.py`)

这是保护API安全的核心。我们创建可复用的依赖项来处理用户认证和角色检查。

```python
# app/api/deps.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from pydantic import ValidationError

from app.core.config import settings
from app.schemas.token_schema import TokenPayload, AuthenticatedUser

# 这个URL仅用于生成OpenAPI文档，后端不实现此端点
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/token")

async def get_current_user(token: str = Depends(oauth2_scheme)) -> AuthenticatedUser:
    """
    解码并验证传入的JWT，如果有效则返回用户信息。
    如果无效，则抛出401 Unauthorized异常。
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(
            token, settings.SUPABASE_JWT_SECRET, algorithms=[settings.ALGORITHM]
        )
        # 将JWT的payload映射到我们的Pydantic模型
        token_data = TokenPayload(**payload)
    except (JWTError, ValidationError):
        # 如果解码失败或payload不符合模型，则认证失败
        raise credentials_exception

    return AuthenticatedUser(id=token_data.sub, role=token_data.role, email=token_data.email)


def require_role(required_role: str):
    """
    一个依赖项工厂，用于创建检查特定用户角色的依赖。
    用法: Depends(require_role("navigator"))
    """
    def role_checker(current_user: AuthenticatedUser = Depends(get_current_user)) -> AuthenticatedUser:
        # 卫语句：检查用户角色
        if current_user.role != required_role:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Operation requires '{required_role}' role.",
            )
        return current_user
    return role_checker
```

### 5\. API端点详细设计 (以`Profile`为例)

我们将完整展示一个资源（用户资料）从数据模型、数据库操作到API路由的完整实现。

#### 5.1 数据模式 (`app/schemas/profile_schema.py`)

```python
from pydantic import BaseModel, Field, UUID4

class ProfileBase(BaseModel):
    username: str | None = Field(None, min_length=3, max_length=50)
    full_name: str | None = Field(None, max_length=100)
    avatar_url: str | None = Field(None, description="URL to user's avatar image")
    bio: str | None = Field(None, max_length=500, description="User's biography")

class ProfileUpdate(ProfileBase):
    pass

class ProfileRead(ProfileBase):
    id: UUID4
    role: str
    email: str

    class Config:
        from_attributes = True # Pydantic v2的配置，用于从ORM对象映射
```

#### 5.2 数据库操作 (`app/crud/crud_profile.py`)

```python
import asyncpg
from uuid import UUID
from app.schemas.profile_schema import ProfileRead, ProfileUpdate

async def get_profile_by_id(conn: asyncpg.Connection, user_id: UUID) -> ProfileRead | None:
    """根据用户ID从数据库获取资料"""
    record = await conn.fetchrow(
        """
        SELECT p.id, u.email, u.role, p.username, p.full_name, p.avatar_url, p.bio
        FROM profiles p
        JOIN auth.users u ON p.id = u.id
        WHERE p.id = $1;
        """,
        user_id
    )
    return ProfileRead.from_attributes(record) if record else None

async def update_profile(
    conn: asyncpg.Connection, user_id: UUID, profile_in: ProfileUpdate
) -> ProfileRead:
    """更新指定用户的资料"""
    # 使用 pydantic 的 model_dump 方法安全地获取需要更新的字段
    update_data = profile_in.model_dump(exclude_unset=True)
    
    # 卫语句：如果没有要更新的字段，则直接返回
    if not update_data:
        return await get_profile_by_id(conn, user_id)

    # 动态构建 SET 子句以避免更新空值
    set_clause = ", ".join([f"{key} = ${i+2}" for i, key in enumerate(update_data.keys())])
    
    query = f"""
        UPDATE profiles
        SET {set_clause}, updated_at = NOW()
        WHERE id = $1
        RETURNING id;
    """
    
    result = await conn.fetchval(query, user_id, *update_data.values())
    
    if not result:
        raise ValueError("Profile not found or update failed")

    return await get_profile_by_id(conn, user_id)
```

#### 5.3 API路由 (`app/api/routers/profile_router.py`)

```python
from uuid import UUID
import asyncpg
from fastapi import APIRouter, Depends, HTTPException, status

from app.api.deps import get_current_user, AuthenticatedUser, get_db_connection
from app.crud import crud_profile
from app.schemas.profile_schema import ProfileRead, ProfileUpdate

router = APIRouter()

@router.get(
    "/me",
    response_model=ProfileRead,
    summary="Get current user's profile"
)
async def read_current_user_profile(
    conn: asyncpg.Connection = Depends(get_db_connection),
    current_user: AuthenticatedUser = Depends(get_current_user)
):
    """获取当前已登录用户的完整个人资料。"""
    profile = await crud_profile.get_profile_by_id(conn, UUID(current_user.id))
    # 正常路径在函数末尾
    return profile

@router.put(
    "/me",
    response_model=ProfileRead,
    summary="Update current user's profile"
)
async def update_current_user_profile(
    profile_in: ProfileUpdate,
    conn: asyncpg.Connection = Depends(get_db_connection),
    current_user: AuthenticatedUser = Depends(get_current_user)
):
    """更新当前用户的个人资料（如用户名、简介等）。"""
    try:
        updated_profile = await crud_profile.update_profile(
            conn, user_id=UUID(current_user.id), profile_in=profile_in
        )
        return updated_profile
    except ValueError as e:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=str(e))
```

### 6\. 错误处理 (`app/main.py`)

我们通过中间件来捕获所有未被处理的异常，防止敏感信息泄露，并提供统一的错误响应格式。

```python
# app/main.py
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse

from app.core.db import lifespan
from app.api.routers import profile_router # 引入其他路由

app = FastAPI(title="启航引路人 API", version="1.0.0", lifespan=lifespan)

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """
    全局异常处理器：捕获所有未处理的异常，记录日志并返回500错误。
    """
    # 在生产环境中，这里应该使用结构化的日志记录器 (e.g., structlog)
    print(f"Unhandled error: {exc}") # 简单的日志记录
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "An internal server error occurred."},
    )

# 挂载API路由
app.include_router(profile_router.router, prefix="/api/v1/profiles", tags=["Profiles"])
# ... 挂载其他路由
```

### 7\. 部署策略 (`Dockerfile`)

我们使用多阶段构建的`Dockerfile`来创建一个优化的、轻量级的生产镜像。

```dockerfile
# ---- Builder Stage ----
FROM python:3.11-slim as builder

WORKDIR /usr/src/app

# 使用Poetry作为依赖管理工具
RUN pip install poetry
COPY poetry.lock pyproject.toml ./
# --no-dev 表示不安装开发依赖
RUN poetry config virtualenvs.create false && poetry install --no-dev --no-root

# ---- Final Stage ----
FROM python:3.11-slim

WORKDIR /usr/src/app

# 从构建阶段拷贝已安装的依赖
COPY --from=builder /usr/src/app/ /usr/local/
# 拷贝应用代码
COPY ./app ./app

# 暴露端口并运行应用
EXPOSE 8000
CMD ["gunicorn", "-w", "4", "-k", "uvicorn.workers.UvicornWorker", "app.main:app", "-b", "0.0.0.0:8000"]
```
# 📱 前端开发完整指南

基于当前完善的 **FastAPI + JWT** 后端架构，为前端开发者提供详细的开发指南。

## 🎯 后端 API 概览

### 🚀 服务地址
- **开发环境**: `http://localhost:8001`
- **API文档**: `http://localhost:8001/docs` (Swagger UI)
- **认证方式**: JWT Bearer Token
- **响应格式**: JSON

### 📋 核心 API 端点

#### 🔐 认证相关
```
POST /api/v1/auth/register    # 用户注册
POST /api/v1/auth/login       # 用户登录  
POST /api/v1/auth/refresh     # Token刷新
```

#### 👤 用户管理
```
GET  /api/v1/users/me         # 获取当前用户完整资料
PUT  /api/v1/users/me         # 更新当前用户资料
GET  /api/v1/users/me/basic   # 获取当前用户基本信息
GET  /api/v1/users/{id}/profile # 获取指定用户公开资料
```

#### 🏥 系统状态
```
GET  /health                  # 健康检查
GET  /                        # 根路径
```

## 🏗️ 推荐前端架构 (Next.js 14+)

### 📁 项目结构
```
/app
├── (auth)/                   # 认证路由组
│   ├── layout.tsx           # 认证布局（简洁样式）
│   ├── login/page.tsx       # 登录页面
│   └── register/page.tsx    # 注册页面
├── (dashboard)/             # 主应用路由组  
│   ├── layout.tsx          # 主布局（导航栏、侧边栏）
│   ├── page.tsx            # 仪表盘首页
│   ├── profile/page.tsx    # 个人资料页
│   ├── settings/page.tsx   # 设置页面
│   └── users/[id]/page.tsx # 用户详情页
├── components/              # 可复用组件
│   ├── auth/               # 认证相关组件
│   │   ├── LoginForm.tsx
│   │   ├── RegisterForm.tsx
│   │   └── AuthGuard.tsx
│   ├── layout/             # 布局组件
│   │   ├── Navbar.tsx
│   │   ├── Sidebar.tsx
│   │   └── Footer.tsx
│   ├── user/               # 用户相关组件
│   │   ├── UserProfile.tsx
│   │   ├── UserCard.tsx
│   │   └── EditProfile.tsx
│   └── ui/                 # 基础UI组件
│       ├── Button.tsx
│       ├── Input.tsx
│       └── LoadingSpinner.tsx
├── lib/                    # 工具函数和配置
│   ├── api/               # API相关
│   │   ├── client.ts      # API客户端配置
│   │   ├── auth.ts        # 认证API
│   │   └── users.ts       # 用户API
│   ├── auth/              # 认证逻辑
│   │   ├── context.tsx    # 认证Context
│   │   ├── hooks.ts       # 认证Hooks
│   │   └── types.ts       # 类型定义
│   ├── utils/             # 工具函数
│   │   ├── storage.ts     # 本地存储
│   │   └── validators.ts  # 表单验证
│   └── constants.ts       # 常量配置
├── types/                 # TypeScript类型定义
│   ├── auth.ts
│   ├── user.ts
│   └── api.ts
└── middleware.ts          # Next.js中间件（路由保护）
```

## 🔑 认证系统集成

### 1. API 客户端配置

```typescript
// lib/api/client.ts
import axios from 'axios';

const API_BASE_URL = 'http://localhost:8001';

// 创建axios实例
export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 请求拦截器 - 自动添加Token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// 响应拦截器 - 处理Token过期
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Token过期，尝试刷新
      try {
        await refreshToken();
        // 重试原请求
        return apiClient.request(error.config);
      } catch (refreshError) {
        // 刷新失败，跳转到登录页
        localStorage.removeItem('access_token');
        window.location.href = '/login';
      }
    }
    return Promise.reject(error);
  }
);

// Token刷新函数
async function refreshToken() {
  const token = localStorage.getItem('access_token');
  if (!token) throw new Error('No token available');
  
  const response = await axios.post(`${API_BASE_URL}/api/v1/auth/refresh`, {}, {
    headers: { Authorization: `Bearer ${token}` }
  });
  
  localStorage.setItem('access_token', response.data.access_token);
  return response.data.access_token;
}
```

### 2. 认证 API 封装

```typescript
// lib/api/auth.ts
import { apiClient } from './client';

export interface LoginRequest {
  username: string;
  password: string;
}

export interface RegisterRequest {
  username: string;
  email?: string;
  password: string;
}

export interface AuthResponse {
  access_token: string;
  token_type: string;
  expires_in: number;
}

export interface User {
  id: number;
  username: string;
  email?: string;
  role: string;
  is_active: boolean;
  created_at: string;
  full_name?: string;
  avatar_url?: string;
  bio?: string;
  location?: string;
  website?: string;
}

// 用户登录
export async function login(data: LoginRequest): Promise<AuthResponse> {
  const formData = new FormData();
  formData.append('username', data.username);
  formData.append('password', data.password);
  
  const response = await apiClient.post('/api/v1/auth/login', formData, {
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
  });
  
  return response.data;
}

// 用户注册
export async function register(data: RegisterRequest): Promise<User> {
  const response = await apiClient.post('/api/v1/auth/register', data);
  return response.data;
}

// 刷新Token
export async function refreshToken(): Promise<AuthResponse> {
  const response = await apiClient.post('/api/v1/auth/refresh');
  return response.data;
}

// 获取当前用户信息
export async function getCurrentUser(): Promise<User> {
  const response = await apiClient.get('/api/v1/users/me');
  return response.data;
}

// 更新用户资料
export async function updateProfile(data: Partial<User>): Promise<User> {
  const response = await apiClient.put('/api/v1/users/me', data);
  return response.data;
}

// 获取用户基本信息
export async function getUserBasic(): Promise<User> {
  const response = await apiClient.get('/api/v1/users/me/basic');
  return response.data;
}

// 获取指定用户公开资料
export async function getUserProfile(userId: number): Promise<User> {
  const response = await apiClient.get(`/api/v1/users/${userId}/profile`);
  return response.data;
}
```

### 3. 认证 Context 和 Hooks

```typescript
// lib/auth/context.tsx
'use client';
import React, { createContext, useContext, useEffect, useState } from 'react';
import { User } from '../api/auth';
import { getCurrentUser, login, register } from '../api/auth';

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (username: string, password: string) => Promise<void>;
  register: (username: string, email: string, password: string) => Promise<void>;
  logout: () => void;
  refreshUser: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // 应用启动时检查Token
    checkAuth();
  }, []);

  async function checkAuth() {
    try {
      const token = localStorage.getItem('access_token');
      if (token) {
        const userData = await getCurrentUser();
        setUser(userData);
      }
    } catch (error) {
      localStorage.removeItem('access_token');
    } finally {
      setLoading(false);
    }
  }

  async function handleLogin(username: string, password: string) {
    try {
      const response = await login({ username, password });
      localStorage.setItem('access_token', response.access_token);
      
      const userData = await getCurrentUser();
      setUser(userData);
    } catch (error) {
      throw error;
    }
  }

  async function handleRegister(username: string, email: string, password: string) {
    try {
      await register({ username, email, password });
      // 注册成功后自动登录
      await handleLogin(username, password);
    } catch (error) {
      throw error;
    }
  }

  function handleLogout() {
    localStorage.removeItem('access_token');
    setUser(null);
  }

  async function refreshUser() {
    try {
      const userData = await getCurrentUser();
      setUser(userData);
    } catch (error) {
      handleLogout();
    }
  }

  return (
    <AuthContext.Provider value={{
      user,
      loading,
      login: handleLogin,
      register: handleRegister,
      logout: handleLogout,
      refreshUser
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

### 4. 路由保护中间件

```typescript
// middleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

export function middleware(request: NextRequest) {
  // 检查是否有token
  const token = request.cookies.get('access_token')?.value;
  
  // 受保护的路径
  const protectedPaths = ['/dashboard', '/profile', '/settings'];
  const isProtectedPath = protectedPaths.some(path => 
    request.nextUrl.pathname.startsWith(path)
  );

  // 认证页面路径
  const authPaths = ['/login', '/register'];
  const isAuthPath = authPaths.some(path => 
    request.nextUrl.pathname.startsWith(path)
  );

  // 如果访问受保护页面但没有token，重定向到登录页
  if (isProtectedPath && !token) {
    return NextResponse.redirect(new URL('/login', request.url));
  }

  // 如果已登录但访问认证页面，重定向到仪表盘
  if (isAuthPath && token) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/dashboard/:path*',
    '/profile/:path*', 
    '/settings/:path*',
    '/login',
    '/register'
  ]
};
```

## 🎨 组件示例

### 1. 登录表单组件

```typescript
// components/auth/LoginForm.tsx
'use client';
import { useState } from 'react';
import { useAuth } from '@/lib/auth/context';
import { useRouter } from 'next/navigation';

export default function LoginForm() {
  const [formData, setFormData] = useState({
    username: '',
    password: ''
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  
  const { login } = useAuth();
  const router = useRouter();

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      await login(formData.username, formData.password);
      router.push('/dashboard');
    } catch (err: any) {
      setError(err.response?.data?.detail || '登录失败');
    } finally {
      setLoading(false);
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div>
        <label htmlFor="username" className="block text-sm font-medium">
          用户名
        </label>
        <input
          id="username"
          type="text"
          required
          value={formData.username}
          onChange={(e) => setFormData(prev => ({
            ...prev,
            username: e.target.value
          }))}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
        />
      </div>

      <div>
        <label htmlFor="password" className="block text-sm font-medium">
          密码
        </label>
        <input
          id="password"
          type="password"
          required
          value={formData.password}
          onChange={(e) => setFormData(prev => ({
            ...prev,
            password: e.target.value
          }))}
          className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
        />
      </div>

      {error && (
        <div className="text-red-600 text-sm">{error}</div>
      )}

      <button
        type="submit"
        disabled={loading}
        className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 disabled:opacity-50"
      >
        {loading ? '登录中...' : '登录'}
      </button>
    </form>
  );
}
```

### 2. 用户资料组件

```typescript
// components/user/UserProfile.tsx
'use client';
import { useState, useEffect } from 'react';
import { useAuth } from '@/lib/auth/context';
import { updateProfile } from '@/lib/api/auth';

export default function UserProfile() {
  const { user, refreshUser } = useAuth();
  const [editing, setEditing] = useState(false);
  const [formData, setFormData] = useState({
    full_name: user?.full_name || '',
    bio: user?.bio || '',
    location: user?.location || '',
    website: user?.website || ''
  });
  const [loading, setLoading] = useState(false);

  async function handleSave() {
    setLoading(true);
    try {
      await updateProfile(formData);
      await refreshUser();
      setEditing(false);
    } catch (error) {
      console.error('更新失败:', error);
    } finally {
      setLoading(false);
    }
  }

  if (!user) return <div>加载中...</div>;

  return (
    <div className="bg-white shadow rounded-lg p-6">
      <div className="flex justify-between items-center mb-4">
        <h2 className="text-xl font-bold">个人资料</h2>
        <button
          onClick={() => setEditing(!editing)}
          className="text-blue-600 hover:text-blue-800"
        >
          {editing ? '取消' : '编辑'}
        </button>
      </div>

      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium text-gray-700">用户名</label>
          <p className="mt-1 text-sm text-gray-900">{user.username}</p>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700">邮箱</label>
          <p className="mt-1 text-sm text-gray-900">{user.email || '未设置'}</p>
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700">真实姓名</label>
          {editing ? (
            <input
              type="text"
              value={formData.full_name}
              onChange={(e) => setFormData(prev => ({
                ...prev,
                full_name: e.target.value
              }))}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
            />
          ) : (
            <p className="mt-1 text-sm text-gray-900">{user.full_name || '未设置'}</p>
          )}
        </div>

        <div>
          <label className="block text-sm font-medium text-gray-700">个人简介</label>
          {editing ? (
            <textarea
              value={formData.bio}
              onChange={(e) => setFormData(prev => ({
                ...prev,
                bio: e.target.value
              }))}
              rows={3}
              className="mt-1 block w-full px-3 py-2 border border-gray-300 rounded-md"
            />
          ) : (
            <p className="mt-1 text-sm text-gray-900">{user.bio || '未设置'}</p>
          )}
        </div>

        {editing && (
          <div className="flex space-x-3">
            <button
              onClick={handleSave}
              disabled={loading}
              className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {loading ? '保存中...' : '保存'}
            </button>
          </div>
        )}
      </div>
    </div>
  );
}
```

## 📦 推荐技术栈

### 核心框架
- **Next.js 14+** - React框架，App Router
- **TypeScript** - 类型安全
- **Tailwind CSS** - 样式框架

### 状态管理
- **React Context** - 用户认证状态
- **SWR 或 React Query** - 服务端状态管理
- **Zustand** (可选) - 复杂本地状态

### UI组件库
- **Headless UI** - 无样式组件
- **Radix UI** - 高质量组件
- **shadcn/ui** - 现代组件库

### 表单处理
- **React Hook Form** - 表单管理
- **Zod** - 表单验证

### HTTP客户端
- **Axios** - HTTP请求库
- **SWR** - 数据获取和缓存

## 🚀 开发流程建议

### 1. 项目初始化
```bash
# 创建Next.js项目
npx create-next-app@latest peerpotal-frontend --typescript --tailwind --app

# 安装必要依赖
npm install axios swr react-hook-form @hookform/resolvers zod
```

### 2. 开发顺序
1. **设置API客户端** - 配置axios和拦截器
2. **实现认证系统** - Context、hooks、API调用
3. **创建基础布局** - 导航栏、侧边栏、footer
4. **开发认证页面** - 登录、注册表单
5. **实现用户功能** - 个人资料、设置页面
6. **添加路由保护** - 中间件和权限控制
7. **完善错误处理** - 全局错误边界和提示

### 3. 测试建议
```bash
# 安装测试依赖
npm install -D @testing-library/react @testing-library/jest-dom jest jest-environment-jsdom

# 运行测试
npm run test
```

## 🔗 重要链接

- **后端API文档**: http://localhost:8001/docs
- **后端健康检查**: http://localhost:8001/health
- **测试用户**: username: `frederick`, password: `123456`

## 📝 注意事项

1. **Token管理**: JWT Token有效期60分钟，需要处理自动刷新
2. **错误处理**: 后端返回中文错误信息，可直接展示给用户
3. **CORS**: 后端已配置CORS，支持localhost:3000
4. **类型定义**: 严格按照后端API响应结构定义TypeScript类型
5. **性能优化**: 使用SWR缓存用户数据，减少重复请求

---

🎉 **后端API已100%就绪，前端可以安心开发！**

